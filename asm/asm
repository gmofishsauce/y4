#!/bin/bash
#
# Copyright Â© 2024 Jeff Berkowitz (pdxjjb@gmail.com)
# 
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public
# License along with this program. If not, see
# <http://www.gnu.org/licenses/>.

# NAME
#   asm - y4 assembler
#
# SYNOPSIS
#   asm sourcefile [options] [sourcefile ...] # default output written y4.out
#
# DESCRIPTION
#   This script runs customasm (https://github.com/hlorenzi/customasm/tree/main)
#   with an embedded ruleset that cause it to assemble the y4 instruction set.
#   If the assembler succeeds, it produces a few lines of console output; if it
#   fails, it produces hopefully-meaningful errors.
#   
#   A "bare" binary, consisting of 2-byte y4 binary opcodes, is written to the
#   the file y4.out on a successful assembly. There are no command line options.
#   Plausible options, e.g. a way to set the output filename or write the output
#   to stdout, may be implemented in the future.

RULES=$(mktemp rules.XXXXXXXX)
trap 'rm -rf -- "$RULES"' EXIT

function usage() {
	>&2 echo "usage: asm [-o outputfile] inputfile"
	exit 1
}

OUTPUT="./y4.out"
while getopts "o:" Option
do
  case $Option in
    o) OUTPUT=$OPTARG
  esac
done
shift $(($OPTIND - 1))

# There must be 1 or more readable files left on the command line.
# Without this, customasm produces confusing error messages in some
# easy to hit error cases, like "asm foo -o bar".
if [ $# -eq 0 ] ; then
	usage
fi
for i in $@ ; do
	if [ ! -r $i ] ; then
		usage
	fi
done

### customasm rules go below the cat. The customasm command is at the end. ###

cat > ${RULES} << 'EOF'

#bankdef user_code
{
	#bits 16
	#labelalign 16
    #addr 0x0000
	#addr_end 0xFFFF
	#outp 0
}

#bankdef user_data
{
    #bits 8
	#labelalign 8
    #addr 0x0000
	#addr_end 0xFFFF
	#outp 8 * 2 * 0x10000
}

#bankdef kern_code
{
	#bits 16
	#labelalign 16
	#addr 0x0000
	#addr_end 0xFFFF
	#outp 8 * 3 * 0x10000
}

#bankdef kern_data
{
    #bits 8
	#labelalign 8
    #addr 0x0000
	#addr_end 0xFFFF
	#outp 8 * 5 * 0x10000
}

#bank kern_code

#subruledef reg
{
    r0 => 0o0
    r1 => 0o1
    r2 => 0o2
    r3 => 0o3
    r4 => 0o4
    r5 => 0o5
    r6 => 0o6
    r7 => 0o7
}

#subruledef wsr ; special registers that can be written
{
	psw => 0o0 ; read/write
}

#subruledef rsr ; special registers that can be read
{
	psw => 0o0 ; read/write
	lnk => 0o1 ; read only - written by jlr
	pc  => 0o2 ; read only - written by all flow control instructions
}

#subruledef imm3 ; only for the currently undefined rB field of jlr
{
	{imm: i3} => imm
}

#subruledef imm6 ; for positive 6-bit immediates in a 7-bit field
{
	{imm: i6} => imm
}

#subruledef imm7 ; 7-bit immediate used in several instructions
{
	{imm: i7} => imm
}

#subruledef imm10 ; 10-bit immediate used in lui only
{
	{imm: i10} => imm
}

#subruledef imm16 ; 16-bit immediate used in psuedo for lui/adi pair
{
	{imm: i16} => imm
}

#ruledef ; all the ops with immediate fields, opcodes 0 through 0xExxx
{
	ldw {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b000   @ imm @ rb @ ra)
	ldb {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b001   @ imm @ rb @ ra)
	stw {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b010   @ imm @ rb @ ra)
	stb {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b011   @ imm @ rb @ ra)
	beq {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b100   @ imm @ rb @ ra)
	adi {ra: reg}, {rb: reg}, {imm: imm7}   => le(0b101   @ imm @ rb @ ra)
	lui {ra: reg}, {imm: imm10}             => le(0b110   @ imm @ ra)
	jlr {ra: reg}, {xx: imm3}, {imm: imm6}  => le(0b111_0 @ imm @ xx @ ra)
}

; All remaining opcodes have 0b1111 = 0xF in the upper four bits.

#ruledef ; XOPs are three-register ops. bic and bis are NAND and OR (PDP-11).
{
	add {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b000  @ rc @ rb @ ra)
	adc {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b001  @ rc @ rb @ ra)
	sub {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b010  @ rc @ rb @ ra)
	sbb {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b011  @ rc @ rb @ ra)
	bic {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b100  @ rc @ rb @ ra)
	bis {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b101  @ rc @ rb @ ra)
	xor {ra: reg}, {rb: reg}, {rc: reg}  => le(0xF @ 0b110  @ rc @ rb @ ra)
}

; All remaining opcodes have 0b1111_111 in the upper seven bits.
; wsr means "writeable special register". rsr "readable special register"

#ruledef ; YOPs are two-register operations.
{
	wrs {ra: wsr}, {rb: reg}  => le(0xF @ 0b111  @ 0b000 @ rb @ ra) ; write special
	rds {ra: rsr}, {rb: reg}  => le(0xF @ 0b111  @ 0b001 @ rb @ ra) ; read special
	lds {ra: wsr}, {rb: reg}  => le(0xF @ 0b111  @ 0b010 @ rb @ ra) ; load special
	sts {ra: rsr}, {rb: reg}  => le(0xF @ 0b111  @ 0b011 @ rb @ ra) ; store special
	y04 {ra: reg}, {rb: reg}  => le(0xF @ 0b111  @ 0b100 @ rb @ ra)
	ior {ra: reg}, {rb: reg}  => le(0xF @ 0b111  @ 0b101 @ rb @ ra)
	iow {ra: reg}, {rb: reg}  => le(0xF @ 0b111  @ 0b110 @ rb @ ra)
}

; All remaining instructions have 1's in the top 10 bits.

#ruledef ; ZOPs are one-register operations.
{
	not {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b000 @ ra)
	neg {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b001 @ ra)
	sxt {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b010 @ ra)
	swb {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b011 @ ra)
	lsr {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b100 @ ra)
	lsl {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b101 @ ra)
	asr {ra: reg} => le(0xF @ 0b111 @ 0b111 @0b110 @ ra)
}

; The remaining instructions have 1's in the top 13 bits and no operands.
; SYS and SRT might be replaced by encodings in the rB field of JLR.
; RTL (return link) is a jump to the link special register. DIE generates
; an illegal instruction fault.

#ruledef ; VOPs are zero-register operations.
{
	sys => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b000)
	srt => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b001)
	v02 => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b010)
	v03 => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b011)
	rtl => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b100)
	hlt => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b101)
	brk => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b110)
	die => le(0xF @ 0b111 @ 0b111 @0b111 @ 0b111)
}

; aliases

#ruledef ; aliases
{
	lli {ra: reg}, {imm: imm6} => asm { adi {ra}, r0, {imm} }
	ldi {ra: reg}, {imm: u16}  => 
	{
		upper_imm = (imm>>6)&0b11_1111_1111 ; imm10
		lower_imm = (imm&0b11_1111)         ; imm6
		asm { lui {ra}, {upper_imm} } @ asm { adi {ra}, r0, {lower_imm} }
	}
	nop => asm { adi r0, r0, 0 }
}

; Pseudos
; section switching is #bank user_code or #bank user_data
; labels are automatically aligned (words in user_code, bytes in user_data)
; .align is #align <bit-alignment>, e.g. .align 2 is #align 16
; .string is #d "string" (or "string\0"). Strings are utf-8
; label: string "four" is label: #d "four"
; and then len = $ - label ; len is 4 ("four" is not nul-terminated)
; .byte is #d8
; .word is #d16
; .space is #res
; .set is #const or sym = expression

EOF

customasm -o "${OUTPUT}" "${RULES}" $@
