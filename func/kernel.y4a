; kernel - loads a 0 in kernel space. Only the first kernel-mode
; MMU register is initialized by hardware, so this part of the
; kernel must fit in the first 4k word page.

#bank code

; 32 2-word vectors. First 8 are hardware interrupt priorities.
; Next 8 are hardware-discovered faults. Last 16 are SYS instructions.

	jmp r5, _reset		; sys 0 - reset vector
	jmp r5, _hwint1	    ; sys 2 - interrupt priority 1
	jmp r5, _hwint2     ; sys 4 - interrupt priority 2
	jmp r5, _hwint3		; sys 6 - interrupt priority 3

	jmp r5, _hwint4		; sys 8 - interrupt priority 4
	jmp r5, _hwint5		; sys 10 - interrupt priority 5
	jmp r5, _hwint6		; sys 12 - interrupt priority 6
	jmp r5, _hwint7		; sys 14 - interrupt priority 7

    ; begin hardware discovered faults

	jmp r5, _illegal		; sys 16
	jmp r5, _mmufault
	jmp r5, _align
	jmp r5, _badtrap

	jmp r5, _badtrap		; sys 24
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _machine

	; begin sys instructions

	jmp r5, _badsys	; trap 32 - illegal instruction fault
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	jmp r5, _badsys	; trap 40
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	jmp r5, _badsys	; trap 48 - page fault
	jmp r5, _badsys		; trap 50 - alignment fault
	jmp r5, _badsys
	jmp r5, _badsys

	jmp r5, _badsys	; trap 56
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys	; trap 62 - machine check

; Word 64 (byte 128) in memory. End of vectors. Begin code.

; Reset the system. The architecture guarantees only that at hardware
; initialization, the WUT-4 will be placed in kernel mode, will begin
; execution at 0, and that the MMU will map physical page 0 at both
; kernel code address 0 and kernel data address 0.
;
; The reset code here maps user code page 0 at physical word address
; 96*1024 (word address 192*1024) and user data page 0 at physical
; byte address 256*1024. This matches the behavior of the program
; loader built into the simulator which supports a tiny 4k code+data
; kernel and allows small test programs with up to 4k of code and 4k
; of data to execute in usermode without any other kernel memory
; management support.
;
; The MmuCtl1 register contains two defined bits. 0x0001 enables
; memory access control. This is not yet implemented. The bit at
; 0x0010 enables the kernel to write into the user mode MMU. This
; is implemented in the emulator.

_reset:					; reset and start.
	lsi r2, 8			; 8 is MmuCtl1 (need defs)
	lsi r1, 0x10		; 0x10 gives kernel access to user MMU
	ssp r1, r2			; write to spr

	ldi r1, 0x18		; 0x18_000 = 0x30_000 / 2 = 96kw (192kb)
	lsi r2, 32			; first user mode code MMU register
	ssp r1, r2			; store 0x18 to user MMU[0] (loader put code there)

	ldi r1, 0x40		; 0x40_000 = 256k where loader put user data
	lsi r2, 48			; first data MMU register
	ssp r1, r2			; store 0x40 to user MMU[16] because MmuCtl1 == 0x10

	lsi r2, 8			; MmuCtl1 register
	ssp r0, r2			; store 0 there so we don't write to user MMU by accident

	lsi r2, 2			; Spr address of Irr
	ssp r0, r2			; store 0 code address in Irr
	rti					; return to usermode at 0 (start)

_hwint1:
_hwint2:
_hwint3:
_hwint4:
_hwint5:
_hwint6:
_hwint7:
    die                 ; TODO hardware interrupts (not yet emulated)

_illegal:               ; TODO illegal instruction fault
_mmufault:				; TODO page fault and segmentation exception
_align:					; TODO alignment fault
_machine:				; TODO machine check
	die

_badsys:	; undefined sys instruction
_badtrap:	; undefined hardware fault
	die

; jump table for fastcalls. We just round it to the next
; (power of 2) - 1 to make bounds checking really simple.
_fasttab:
#d16 _syserr ; sys FASTSYS ; 0 in r1 => error
#d16 exit    ; sys FASTSYS ; 1 in r1, exit code in r2
#d16 debug   ; sys FASTSYS ; 2 in r1
#d16 putc    ; sys FASTSYS ; 3 in r1, byte in r2
#d16 _syserr ; 4
#d16 _syserr ; 5
#d16 _syserr ; 6
#d16 _syserr ; 7
FASTTAB_MAX = 7

_fastsys:	 ; fast system calls
	; TODO copy user registers to kernel registers
	add r4, r0, r1
	lsi r5, FASTTAB_MAX
	bic r4, r4, r5 ; argument &= ^FASTTAB_MAX
	beq r4, r1, _1f ; if result != argument, skip
	jmp r4, _syserr ; oops, bad argument
_1f:
	ldi	r4, _fasttab
	add r4, r4, r1
	jmp r4

_syscall:	; TODO ordinary system calls that can move data
	die
_syserr:
	die		; TODO undefined system call

; exit - exit code in r2
exit:
	hlt

; debug - simulator register dump - no arguments
debug:
	brk

; putc - byte in r2
putc:
	die
