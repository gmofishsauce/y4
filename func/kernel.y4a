; kernel - loads a 0 in kernel space. Only the first kernel-mode
; MMU register is initialized by hardware, so this part of the
; kernel must fit in the first 4k word page.

#bank code

; 32 2-word vectors. First 16 correspond to sys instructions.
; The second group of 16 are injected by hardware or unused.

	jmp r5, _reset		; sys 0 - reset vector
	jmp r5, _fastsys	; sys 2 - fast system calls
	jmp r5, _syscall	; sys 4 - system calls
	jmp r5, _badsys		; sys 6 - not used

	jmp r5, _badsys		; sys 8 - not used
	jmp r5, _badsys		; sys 10 - not used
	jmp r5, _badsys		; sys 12 - not used
	jmp r5, _badsys		; sys 14 - not used

	jmp r5, _badsys		; sys 16
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	jmp r5, _badsys		; sys 24
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	; begin injected hardware faults

	jmp r5, _illegal	; trap 32 - illegal instruction fault
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _badtrap	; trap 40
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _mmufault	; trap 48 - page fault
	jmp r5, _align		; trap 50 - alignment fault
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _badtrap	; trap 56
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _machine	; trap 62 - machine check

; Word 64 in memory. End of vectors. Begin code.

; Reset the system. The architecture guarantees only that at hardware
; initialization, the WUT-4 will be placed in kernel mode, will begin
; execution at 0, and that the MMU will map physical page 0 at both
; code address 0 and data address 0. The simulator actually initializes 
; all the MMU registers to 0.
;
; The reset code here maps user code page 0 at physical address 192*1024
; and user data page 0 at physical address 256*1024. This matches the
; behavior of the program loader built into the simulator and allows
; small test programs with up to 4k of code and 4k of data to execute
; in usermode without any other kernel memory management support.
;
; TODO implement an MMU control register so the kernel can write into
; the usermode MMU registers. Put 48 in the user MMU register 0 (address
; 192k) and 64 in the user MMU register 16 (address 256k). Then return
; into usermode.

_reset:					; reset and start.
	lsi r2, 8			; 8 is MmuCtl1 (need defs)
	lsi r1, 0x10		; 0x10 gives kernel access to user MMU
	ssp r1, r2			; write to spr

	ldi r1, 0x30		; 0x30_000 = 192k where loader put user code
	lsi r2, 32			; first code MMU register
	ssp r1, r2			; store 0x30 to user MMU[0] because MmuCtl1 == 0x10

	ldi r1, 0x40		; 0x40_000 = 256k where loader put user data
	lsi r2, 48			; first data MMU register
	ssp r1, r2			; store 0x40 to user MMU[16] because MmuCtl1 == 0x10

	lsi r2, 8			; MmuCtl1 register
	ssp r0, r2			; store 0 there so we don't write to user MMU by accident

	lsi r2, 2			; Spr address of Irr
	ssp r0, r2			; store 0 code address in Irr
	rti					; return to usermode at 0 (start)

_machine:				; TODO machine check
	die

_mmufault:				; TODO page fault and segmentation exception
	die

_align:					; TODO alignment fault
	die

; I'd like to know how to assert that $ at this point is < 4096.
; That's the end of the code that must be in page 0. Depending
; on the design of the kernel, it may be important to put other
; code in page 0. This is TBD. The rest can go anywhere.

_badsys:	; undefined sys instruction
_badtrap:	; undefined hardware fault
	die

_illegal:	; TODO illegal instruction fault
	die
_syserr:
	die		; TODO undefined system call

; jump table for fastcalls. We just round it to the next
; (power of 2) - 1 to make bounds checking really simple.
_fasttab:
#d16 _syserr ; sys FASTSYS ; 0 in r1 => error
#d16 exit    ; sys FASTSYS ; 1 in r1, exit code in r2
#d16 debug   ; sys FASTSYS ; 2 in r1
#d16 putc    ; sys FASTSYS ; 3 in r1, byte in r2
#d16 _syserr ; 4
#d16 _syserr ; 5
#d16 _syserr ; 6
#d16 _syserr ; 7
FASTTAB_MAX = 7

_fastsys:	 ; fast system calls
	; TODO copy user registers to kernel registers
	add r4, r0, r1
	lsi r5, FASTTAB_MAX
	bic r4, r4, r5 ; argument &= ^FASTTAB_MAX
	beq r4, r1, _1f ; if result != argument, skip
	jmp r4, _syserr ; oops, bad argument
_1f:
	ldi	r4, _fasttab
	add r4, r4, r1
	jmp r4

_syscall:	; TODO ordinary system calls that can move data
	die

; exit - exit code in r2
exit:
	hlt

; debug - simulator register dump - no arguments
debug:
	brk

; putc - byte in r2
putc:
	die
