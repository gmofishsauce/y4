; kernel - loads a 0 in kernel space. Only the first kernel-mode
; MMU register is initialized by hardware, so this part of the
; kernel must fit in the first 4k word page.

#bank code

; 32 2-word vectors. First 16 correspond to sys instructions.
; The second group of 16 are injected by hardware or unused.

	jmp r5, _reset		; sys 0 - reset vector
	jmp r5, _fastsys	; sys 2 - fast system calls
	jmp r5, _syscall	; sys 4 - system calls
	jmp r5, _badsys		; sys 6 - not used

	jmp r5, _badsys		; sys 8 - not used
	jmp r5, _badsys		; sys 10 - not used
	jmp r5, _badsys		; sys 12 - not used
	jmp r5, _badsys		; sys 14 - not used

	jmp r5, _badsys		; sys 16
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	jmp r5, _badsys		; sys 24
	jmp r5, _badsys
	jmp r5, _badsys
	jmp r5, _badsys

	; begin injected hardware faults

	jmp r5, _illegal	; trap 32 - illegal instruction fault
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _badtrap	; trap 40
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _mmufault	; trap 48 - page fault
	jmp r5, _align		; trap 50 - alignment fault
	jmp r5, _badtrap
	jmp r5, _badtrap

	jmp r5, _badtrap	; trap 56
	jmp r5, _badtrap
	jmp r5, _badtrap
	jmp r5, _machine	; trap 62 - machine check

; Word 64 in memory. End of vectors. Begin code.

_reset:					; reset and start.
	lsi r2, 2			; Spr address of Irr
	lsi r1, 0			; 0 address in user code space
	ssp r1, r2			; store in Irr
	rti					; return to usermode at 0 (start)

_machine:				; TODO machine check
	die

_mmufault:				; TODO page fault and segmentation exception
	die

_align:					; TODO alignment fault
	die

; I'd like to know how to assert that $ at this point is < 4096.
; That's the end of the code that must be in page 0. Depending
; on the design of the kernel, it may be important to put other
; code in page 0. This is TBD. The rest can go anywhere.

_badsys:	; undefined sys instruction
_badtrap:	; undefined hardware fault
	die

_illegal:	; TODO illegal instruction fault
	die
_syserr:
	die		; TODO undefined system call

; jump table for fastcalls. We just round it to the next
; (power of 2) - 1 to make bounds checking really simple.
_fasttab:
#d16 _syserr ; sys FASTSYS ; 0 in r1 => error
#d16 exit    ; sys FASTSYS ; 1 in r1, exit code in r2
#d16 debug   ; sys FASTSYS ; 2 in r1
#d16 putc    ; sys FASTSYS ; 3 in r1, byte in r2
#d16 _syserr ; 4
#d16 _syserr ; 5
#d16 _syserr ; 6
#d16 _syserr ; 7
FASTTAB_MAX = 7

_fastsys:	 ; TODO fast read-only system calls
	; TODO copy user registers to kernel registers
	add r4, r0, r1
	lsi r5, FASTTAB_MAX
	bic r4, r4, r5 ; argument &= ^FASTTAB_MAX
	beq r4, r1, _1f ; if result != argument, skip
	jmp r4, _syserr ; oops, bad argument
_1f:
	ldi	r4, _fasttab
	add r4, r4, r1
	jmp r4

_syscall:	; TODO ordinary system calls that can move data
	die

; exit - exit code in r2
exit:
	hlt

; debug - simulator register dump - no arguments
debug:
	brk

; putc - byte in r2
putc:
	die
